//
//  ViewCalendarViewController.swift
//  Rooted
//
//  Created by Michael Westbrooks on 7/17/20.
//  Copyright (c) 2020 RedRooster Technologies Inc.. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CalendarKit
import DateToolsSwift
import EachNavigationBar
import Sheeeeeeeeet

protocol ViewCalendarDisplayLogic: class { }

protocol ViewCalendarDelegate: class {
  func selectTimePeriod(_ sender: ViewCalendarViewController, period: CalendarKitEvent)
}

class ViewCalendarViewController: ResponsiveViewController, RootedContentDisplayLogic {

  var interactor: RootedContentBusinessLogic?
  private var startDatePicker = WWCalendarTimeSelector.instantiate()
  private var navTitle = ""
  private var navBarHeight: CGFloat = 60

  public lazy var dayView: DayView = DayView()
  public lazy var navigationBar: EachNavigationBar = EachNavigationBar()

  public var dataSource: EventDataSource? {
    get {
      return dayView.dataSource
    }
    set(value) {
      dayView.dataSource = value
    }
  }

  public var delegate: DayViewDelegate? {
    get {
      return dayView.delegate
    }
    set(value) {
      dayView.delegate = value
    }
  }

  public var calendar = Calendar.autoupdatingCurrent
  public weak var viewCalendarDelegate: ViewCalendarDelegate?

  // MARK: - Lifecycle methods
  static func setupViewController() -> ViewCalendarViewController {
    let storyboard = UIStoryboard(name: kStoryboardMain, bundle: nil)
    let viewController = storyboard.instantiateViewController(withIdentifier: "ViewCalendarViewController") as! ViewCalendarViewController
    return viewController
  }

  // MARK: Object lifecycle
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
  
  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }
  
  // MARK: Setup
  private func setup() {
    let viewController = self
    let interactor = RootedContentInteractor()
    let presenter = RootedContentPresenter()
    viewController.interactor = interactor
    interactor.presenter = presenter
    presenter.viewController = viewController
  }
  
  // MARK: View lifecycle
  override func loadView() {
    let containerView = UIView(frame: CGRect(x: .zero,
                                             y: .zero,
                                             width: kWidthOfScreen,
                                             height: kHeightOfScreen))
    let statusBarHeight: CGFloat = .zero

    let navbar = EachNavigationBar(viewController: self)
    navbar.frame = CGRect(x: .zero,
                          y: statusBarHeight,
                          width: UIScreen.main.bounds.width,
                          height: navBarHeight)
    navbar.barTintColor = .systemOrange
    navbar.prefersLargeTitles = true

    let navitem = UINavigationItem()

    let backButton = UIBarButtonItem(image: UIImage(named: "left-arrow-line-symbol")!.maskWithColor(color: .white),
                                     style: .plain,
                                     target: self,
                                     action: #selector(dismiss(_:)))
    backButton.tintColor = .white

    let monthSelector = UIBarButtonItem(image: UIImage(named: "weekly-calendar-sm")!.maskWithColor(color: .white),
                                        style: .plain,
                                        target: self,
                                        action: #selector(showDatePicker(_:)))
    monthSelector.tintColor = .white

    let refreshButton = UIBarButtonItem(image: UIImage(named: "refresh-old")!.maskWithColor(color: .white),
                                        style: .plain,
                                        target: self,
                                        action: #selector(resetToCurrentMonth(_:)))
    refreshButton.tintColor = .white
    
    let syncCalendarButton = UIBarButtonItem(image: UIImage(named: "download-from-internet-cloud")!.maskWithColor(color: .white),
                                             style: .plain,
                                             target: self,
                                             action: #selector(syncCalendars(_:)))
    syncCalendarButton.tintColor = .white

    navitem.leftBarButtonItems = [ backButton, refreshButton ]

    navitem.rightBarButtonItems = [ monthSelector, syncCalendarButton ]
    navitem.largeTitleDisplayMode = .always

    navbar.shadow = .none
    navbar.items = [ navitem ]
    navbar.tintColor = .white
    navbar.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
    navbar.largeTitleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]

    navigationBar = navbar
    
    dayView = DayView(frame: CGRect(x: .zero,
                                    y: navigationBar.frame.maxY - 10,
                                    width: kWidthOfScreen,
                                    height: kHeightOfScreen - 160))
    dayView.calendar = calendar
    containerView.addSubview(navigationBar)
    containerView.addSubview(dayView)
    view = containerView
  }
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    startDatePicker.delegate = self
    startDatePicker.optionIdentifier = "start_date"
    startDatePicker.optionCurrentDate = Date()
    startDatePicker.optionShowTopPanel = false
    
    let style = WWCalendarTimeSelectorStyle()
    style.showTime(false)
    startDatePicker.optionStyles = style

    edgesForExtendedLayout = []
    view.tintColor = SystemColors.systemRed

    dataSource = self
    delegate = self

    let sizeClass = traitCollection.horizontalSizeClass
    configureDayViewLayoutForHorizontalSizeClass(sizeClass)

    dayView.scrollToFirstEventIfNeeded()
    moveToDate = Date()

    reloadData()
  }

    open override func willTransition(to newCollection: UITraitCollection, with coordinator: UIViewControllerTransitionCoordinator) {
      super.willTransition(to: newCollection, with: coordinator)
      configureDayViewLayoutForHorizontalSizeClass(newCollection.horizontalSizeClass)
    }
    
  open func configureDayViewLayoutForHorizontalSizeClass(_ sizeClass: UIUserInterfaceSizeClass) {
    dayView.transitionToHorizontalSizeClass(sizeClass)
  }

    var eventsForCalendar = [Event]() {
        didSet {
            reloadData()
        }
    }
  func retrieveMeetings(forDate date: Date) {
    var request = RootedContent.RetrieveMeetings.Request()
    request.contentDB = .remote
    request.date = date
    interactor?.retrieveMeetings(request: request)
  }

  func onDidFinishLoading(viewModel: RootedContent.RetrieveMeetings.ViewModel) {
    dismissHUD()
    guard let meetings = viewModel.meetings else { return }
    
    // Update table for meetings
    let evts = meetings.map { contextWrapper -> Event in
      let event = Event()
      if let startDate = contextWrapper.meeting?.meetingDate?.startDate?.toDate()?.date {
        event.startDate = startDate
      }
      if let endDate = contextWrapper.meeting?.meetingDate?.endDate?.toDate()?.date {
        event.endDate = endDate

        if Date.today().isGreaterThanDate(endDate) {
          event.color = .lightGray
          event.textColor = .darkText
        } else {
          event.color = .systemOrange
          event.textColor = .darkText
        }
      }

      if let meetingName = contextWrapper.meeting?.meetingName {
        event.text = String(format: kCaptionTitle, arguments: [meetingName])
      }

      if let meeting = contextWrapper.meeting {
        event.userInfo = meeting.toJSON()
      }
      return event
    }
    eventsForCalendar.append(contentsOf: evts)
  }
    
    func fetchMeetingsFromCalendar(forDate date: Date, clearPrecedingEvents: Bool = false) {
        var request = RootedContent.FetchCalendarMeetings.Request()
        request.date = date
        request.shouldClearPrecedingEvents = clearPrecedingEvents
        request.shouldShowFreeTime = DefaultsManager.shared.retrieveBoolDefault(forKey: kShowFreeTimeOnCalendarView) ?? false
        interactor?.fetchMeetingsFromCalendar(request: request)
    }
    
    func onDidFinishFetching(viewModel: RootedContent.FetchCalendarMeetings.ViewModel) {
        guard let meetings = viewModel.meetings else { return }
        eventsForCalendar.append(contentsOf: meetings)
    }

  @objc func dismiss(_ sender: Any) {
    dismiss(animated: true, completion: nil)
  }

  fileprivate var moveToDate: Date! {
    didSet {
      eventsForCalendar.removeAll()
      move(to: moveToDate)
      dayView.scrollTo(hour24: Float(moveToDate.hour))
      checkCalendarPermissions()
    }
  }
    
  @objc func incrementMonth(_ sender: Any) {
    guard let incrementMonth = moveToDate.add(months: 1) else { return }
    moveToDate = incrementMonth
  }

  @objc func deIncrementMonth(_ sender: Any) {
    guard let incrementMonth = moveToDate.add(months: -1) else { return }
    moveToDate = incrementMonth
  }

  @objc func resetToCurrentMonth(_ sender: Any) {
    moveToDate = Date()
  }

  @objc func showDatePicker(_ sender: Any) {
    present(startDatePicker, animated: true, completion: nil)
  }
    
  @objc func syncCalendars(_ sender: Any) {
    let headerView = MenuTitle(title: "Sync Calendars", subtitle: "Consolidate supported calendars into one calendar view.")
    let calendarSection = SectionTitle(title: "Supported Integrations")
    let appleCalendarButton = MultiSelectItem(title: "Apple Calendar",
                                              subtitle: nil,
                                              isSelected: DefaultsManager.shared.retrieveBoolDefault(forKey: kCalendarSyncAppleCalendar) ?? false,
                                              group: "primary_calendars",
                                              value: "apple_calendar",
                                              image: nil)
    
    let optimzationSection = SectionTitle(title: "Optimizations")
    let showFreeTimeSwitch = SelectItem(title: "Show Free Time",
                                        subtitle: nil,
                                        isSelected: DefaultsManager.shared.retrieveBoolDefault(forKey: kShowFreeTimeOnCalendarView) ?? false,
                                        group: "show_free_time_on_calendar_view",
                                        value: nil,
                                        image: nil,
                                        tapBehavior: .none)

    let okButton = OkButton(title: "Sync")
    let cancelButton = CancelButton(title: "Cancel")
    let menu = Menu(items: [headerView, calendarSection , appleCalendarButton, optimzationSection, showFreeTimeSwitch, okButton, cancelButton])
    
    let sheet = menu.toActionSheet { (sheet, menuItem) in
        switch menuItem.title {
        case "Sync":
            
            for menuItem in sheet.items {
                if let multiSelect = menuItem as? MultiSelectItem {
                    switch multiSelect.group {
                    case "primary_calendars":
                        switch multiSelect.title {
                        case "Apple Calendar":
                            print("Selected apple calendar")
                            DefaultsManager.shared.setDefault(withData: multiSelect.isSelected, forKey: kCalendarSyncAppleCalendar)
                            self.eventsForCalendar.removeAll()
                            self.reloadData()
                            self.checkCalendarPermissions()
                        default:
                            break
                        }
                    default:
                        break
                    }
                }
              if let selectItem = menuItem as? SelectItem {
                switch selectItem.group {
                  case "show_free_time_on_calendar_view":
                    switch selectItem.title {
                    case "Show Free Time":
                        DefaultsManager.shared.setDefault(withData: selectItem.isSelected, forKey: kShowFreeTimeOnCalendarView)
                        self.eventsForCalendar.removeAll()
                        self.reloadData()
                        self.checkCalendarPermissions()
                    default:
                        break
                    }
                  default:
                      break
                  }
              }
            }

        default:
            break
        }
    }
    
    sheet.present(in: self, from: self.view)
  }
}

// MARK: - EventDataSource + DayViewDelegate
extension ViewCalendarViewController: EventDataSource, DayViewDelegate {
  func eventsForDate(_ date: Date) -> [EventDescriptor] {
    return eventsForCalendar
  }

  func dayViewDidSelectEventView(_ eventView: EventView) {
    print("Event has been selected, navigate to details")
    if
      let event = eventView.descriptor as? Event,
      let selectedMeetingDict = event.userInfo as? [String: Any] {
      
      if
        let selectedFreeTimeBlockIdentifier = selectedMeetingDict["identifier"] as? String,
        selectedFreeTimeBlockIdentifier == "free_time_block" {
        self.viewCalendarDelegate?.selectTimePeriod(self, period: event)
        self.dismiss(animated: true, completion: nil)
      } else if let selectedMeeting = Meeting(JSON: selectedMeetingDict) {

        let viewModel = RootedCellViewModel(data: selectedMeeting, delegate: nil)
        let destination = InviteDetailsViewController.setupViewController(meeting: viewModel)
        self.present(destination, animated: true, completion: nil)
      }
    }
  }

  func dayViewDidLongPressEventView(_ eventView: EventView) {
    print("Event has been long pressed")
  }

  func dayView(dayView: DayView, didTapTimelineAt date: Date) {
    print("DayView = \(dayView) did tap timeline at = \(date.toString(.rooted))")
    let destinationVC = CreateMeetingViewController.setupViewController(draftMeeting: nil)
    present(destinationVC, animated: true, completion: nil)
  }

  func dayViewDidBeginDragging(dayView: DayView) {
    // Do nothing
  }

  func dayView(dayView: DayView, willMoveTo date: Date) {
    print("DayVew = \(dayView) will move to = \(date)")
  }

  func dayView(dayView: DayView, didMoveTo date: Date) {
    print("DayView = \(dayView) did move to = \(date)")
    moveToDate = date
  }

  func dayView(dayView: DayView, didLongPressTimelineAt date: Date) {
    print("DayView = \(dayView) did long press timeline at = \(date)")
  }

  func dayView(dayView: DayView, didUpdate event: EventDescriptor) {
    // Do nothing
  }
}

// MARK: - CalendarKit API
extension ViewCalendarViewController {
  func move(to date: Date) {
    dayView.move(to: date)
  }

  func reloadData() {
    dayView.reloadData()
  }

  func updateStyle(_ newStyle: CalendarStyle) {
    dayView.updateStyle(newStyle)
  }

  func create(event: EventDescriptor, animated: Bool = false) {
    dayView.create(event: event, animated: animated)
  }

  func beginEditing(event: EventDescriptor, animated: Bool = false) {
    dayView.beginEditing(event: event, animated: animated)
  }

  func endEventEditing() {
    dayView.endEventEditing()
  }
}

// MARK: - Reusable UI+UX use cases
extension ViewCalendarViewController {
  // MARK: - Use Case: Show ProgressHUD
  func showHUD() {
    DispatchQueue.main.async {
      self.progressHUD?.show()
    }
  }

  // MARK: - Use Case: Dismiss ProgressHUD
  func dismissHUD() {
    DispatchQueue.main.async {
      self.progressHUD?.dismiss()
    }
  }

  // MARK: - Use Case: Check if app has access to calendar permissions
  func checkCalendarPermissions() {
    let request = RootedContent.CheckCalendarPermissions.Request()
    interactor?.checkCalendarPermissions(request: request)
  }

  func handleCalendarPermissions(viewModel: RootedContent.CheckCalendarPermissions.ViewModel) {
    RRLogger.log(message: "Calendar Permissions: \(viewModel.isGranted)", owner: self)
    if viewModel.isGranted {
      // Get meetings
//      self.retrieveMeetings(forDate: moveToDate)
        if let appCanSyncAppleCalendar = DefaultsManager.shared.retrieveBoolDefault(forKey: kCalendarSyncAppleCalendar), appCanSyncAppleCalendar {
            self.fetchMeetingsFromCalendar(forDate: moveToDate)
        }
    } else {
      self.showCalendarError()
    }
  }

  private func showCalendarError() {
     self.showError(title: kCalendarPermissions, message: kCalendarAccess)
  }
}

// MARK: - WWCalendarTimeSelectorProtocol
extension ViewCalendarViewController: MeetingsManagerDelegate {
  func didFailToLoad(_ manager: Any?, error: Error) {
    dismissHUD()
    RRLogger.logError(message: "didFailToLoad with an error", owner: self, error: error)
    showError(title: "Error", message: error.localizedDescription)
  }

  func didFinishLoading(_ manager: Any?, invites: [MeetingContextWrapper]) {
    // Handle some additional business logic
    dismissHUD()
    // Filter invites by segment index
  }
}

// MARK: - WWCalendarTimeSelectorProtocol
extension ViewCalendarViewController: WWCalendarTimeSelectorProtocol {
  func WWCalendarTimeSelectorDone(_ selector: WWCalendarTimeSelector, date: Date) {
    moveToDate = date
  }
}
